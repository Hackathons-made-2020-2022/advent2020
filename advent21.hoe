#!/bin/sh

hoe2 '
let
foo x = not . flip elem x
fixf f = fst . head . dropWhile (uncurry (/=)) . uncurry zip . (id &&& tail) . iterate f
reduce l = map (second (\\ map fst s) . first (\\ concatMap snd s)) l
	where
	s = filter ((==1).length.snd)
		$ M.toList
		$ foldr (M.unionWith intersect) M.empty
		$ concatMap (\(i,a) -> [M.singleton l i | l<-a])
		$ l
in
length
.
(\(a,b) -> concatMap (filter (flip elem b)) a)
.
(map fst &&& concatMap fst . fixf reduce)
.
map (words . takeWhile (foo "(") &&& tail . words . filter (foo ",") . init . dropWhile (foo "("))
.
lines
'

