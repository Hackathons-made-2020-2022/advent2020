#!/bin/sh

hoe -m 'Data.Tree' '
let

readInt :: String -> Int
readInt = read

match     x = and $ zipWith aligned x (tail x)
aligned a b = and $ zipWith (==) (map last a) (map head b)
check     x = all match $ (map (map snd)) $ x ++ transpose x
square    x = chunksOf (side x) x
side      x = floor (sqrt (fromIntegral (length x)))

permute s n p [] = [[]]
permute s n p xs = [y : ys | x <- xs, y <- flip x, (mod n s == 0 || aligned (snd p) (snd y)), ys <- permute s (succ n) y (delete x xs)]

res x
	= sum
	$ map fst
		[ head $ head x
		, last $ head x
		, head $ last x
		, last $ last x
		]

flip x =
	map (\f -> second f x)
	[ id
	, reverse
	, map reverse
	, reverse . map reverse
	]

in
-- res
-- .
-- head
-- .
-- filter check
-- .
-- map square
-- .
(\x -> permute (side x) 0 undefined x)
.
map (readInt . filter isDigit . head &&& tail)
.
splitOn [""]
'

